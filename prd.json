{
  "project": "GasTownUI",
  "projectPath": "/home/jaden-burton/gt/gastownUIOther",
  "branchName": "ralph/fix-circuit-breaker-false-trips",
  "description": "Fix circuit breaker false trips that block the messages page and other functional CLI endpoints. Invalid CLI commands, a shared global circuit breaker, and unhandled beads DB absence cause cascading failures.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Add error classification to CircuitBreaker",
      "description": "As a developer, I need CircuitBreaker to distinguish infrastructure failures from command-level errors so that wrong flags or missing databases don't trip the breaker.",
      "acceptanceCriteria": [
        "Add recordCommandError() method to CircuitBreaker class in src/lib/server/cli/circuit-breaker.ts that does NOT increment failureCount and does NOT change state",
        "Existing recordSuccess() and recordFailure() behavior unchanged",
        "getStats() return type updated to include commandErrorCount (new counter incremented by recordCommandError)",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "This is a foundational change that US-003 and US-004 depend on."
    },
    {
      "id": "US-002",
      "title": "Refactor ProcessSupervisor to use per-domain circuit breakers",
      "description": "As a developer, I want circuit breakers isolated by command domain so failures in one area cannot block unrelated commands.",
      "acceptanceCriteria": [
        "In src/lib/server/cli/process-supervisor.ts, replace the single CircuitBreaker instance with a Map<string, CircuitBreaker>",
        "Add private method getDomainKey(config: CLICommandConfig): string that returns `${config.command}-${config.args[0] || 'default'}` as the domain key (e.g. 'gt-mail', 'gt-mq', 'bd-list', 'bd-gate')",
        "Add private method getBreaker(domain: string): CircuitBreaker that returns existing breaker or creates a new one with the configured threshold and resetTime",
        "Update execute() to call canExecute() on the domain-specific breaker (derive domain from commandConfig)",
        "Update executeCommand() to call recordSuccess() / recordFailure() on the domain-specific breaker",
        "Update getStats() to return stats for all domain breakers as a Record<string, CircuitBreakerStats>",
        "Update resetCircuitBreaker() to accept optional domain parameter — if provided reset only that domain, otherwise reset all",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "The error message in execute() when breaker is open should include the domain name: 'Circuit breaker is open for domain [X] - CLI is unavailable'."
    },
    {
      "id": "US-003",
      "title": "Classify errors in ProcessSupervisor.executeCommand",
      "description": "As a developer, I want executeCommand to detect command-level errors (wrong flags, missing DB) and call recordCommandError() instead of recordFailure().",
      "acceptanceCriteria": [
        "In the error handler of executeCommand() in process-supervisor.ts, before calling recordFailure(), check stderr for known command-error patterns: 'unknown flag', 'unknown command', 'no beads database found', 'Error: unknown', 'not a valid command'",
        "If stderr matches a command-error pattern AND the process was not killed/timed out, call recordCommandError() on the domain breaker instead of recordFailure()",
        "Still return { success: false } with the original error message — only the circuit breaker recording changes",
        "Infrastructure errors (spawn failure, timeout, killed, ENOENT) still call recordFailure()",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "This pairs with US-001. Even after fixing commands in US-004/005/006, this safeguard prevents future bad commands from cascading."
    },
    {
      "id": "US-004",
      "title": "Fix gt mq command in SSE polling and mergequeue endpoint",
      "description": "As a user, I want merge queue polling to use the correct CLI syntax so it stops generating failures.",
      "acceptanceCriteria": [
        "In src/routes/api/gastown/events/+server.ts Step 6 (merge queue fetch, around line 502): replace `supervisor.gt(['mq', '--json'])` with a per-rig loop that calls `supervisor.gt(['mq', 'list', rigName, '--json'])` for each rig in rigNames",
        "Aggregate results from all rigs into a single items array before emitting the mergequeue SSE event",
        "If rigNames is empty, skip merge queue polling entirely (no CLI call)",
        "Wrap in try/catch so merge queue failure is non-fatal (same pattern as other steps)",
        "In src/routes/api/gastown/mergequeue/+server.ts: read the file first, then fix the gt mq command to use 'gt mq list <rig> --json'. Accept rig name from URL query parameter (?rig=name). If no rig param, use getRigNames() and aggregate across all rigs",
        "SSE event shape for mergequeue unchanged: { items: [...], total: number }",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "gt mq list requires a rig name argument. The SSE loop already has rigNames available from Step 1."
    },
    {
      "id": "US-005",
      "title": "Fix molecule endpoint commands",
      "description": "As a user, I want the molecules API endpoints to use correct gt mol subcommands so they return real data.",
      "acceptanceCriteria": [
        "In src/routes/api/gastown/molecules/+server.ts: replace ['mol', 'list', '--active', '--json'] with ['mol', 'status', '--json'] which shows what's on the current agent's hook",
        "Parse the response from gt mol status --json and map it to the existing response shape { items: [...], total: number }. If the response is a single object (not array), wrap it in an array. If no molecule is attached, return { items: [], total: 0 }",
        "In src/routes/api/gastown/molecules/[id]/+server.ts: replace ['mol', 'show', id, '--json'] with ['mol', 'progress', id, '--json'] which shows execution progress for a molecule by its root issue ID",
        "Both endpoints return proper JSON responses matching existing shapes",
        "Both endpoints handle 'no beads database found' errors gracefully (return empty data, not 500)",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": "gt mol status --json shows hook status. gt mol progress <id> --json shows step progress. Both accept --json."
    },
    {
      "id": "US-006",
      "title": "Handle missing beads database gracefully in SSE polling",
      "description": "As a user, I want the SSE event stream to skip beads-dependent commands when no database exists instead of failing repeatedly.",
      "acceptanceCriteria": [
        "In src/routes/api/gastown/events/+server.ts, add a beadsAvailable flag initialized to false",
        "Before the first bd command in each poll cycle, probe beads availability by running supervisor.bd(['version'], { timeout: 5000 }) and cache the result. Re-probe every 60 seconds (track lastBeadsCheck timestamp)",
        "If beadsAvailable is false, skip: bd list --json (tasks), bd list --type=convoy --json (convoys), bd gate list --json (gates)",
        "When skipping, emit events with empty data and a 'beadsUnavailable: true' flag so the UI can show appropriate messaging: e.g. { type: 'tasks', data: { tasks: [], total: 0, beadsUnavailable: true } }",
        "Skipped polls do NOT set pollHadFailure = true",
        "When beads becomes available on re-probe, resume normal polling immediately",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "bd version is a lightweight command that succeeds if bd can find a database. Use it as the probe."
    }
  ]
}
